import streamlit as st
import pandas as pd
from typing import Dict, List, Tuple, Any, Optional

from utils.cortex_llm import get_affiliation_priorities_from_llm
from utils.affiliation_updates import set_primary_affiliation


def build_affiliations_dict(
    db_affiliations_df: pd.DataFrame,
    ai_affiliations: List[Dict[str, Any]],
    entity_name: str = "",
    entity_type: str = "HCP"
) -> Dict[str, Dict[str, Any]]:
    """
    Build a combined dictionary of affiliations from database and AI sources.
    
    Args:
        db_affiliations_df: DataFrame with affiliations from database
        ai_affiliations: List of affiliations from Perplexity AI
        entity_name: Name of the entity (to filter out self-references)
        entity_type: "HCP" or "HCO"
        
    Returns:
        Dictionary mapping affiliation keys to affiliation data
    """
    all_affiliations = {}
    
    # Add database affiliations
    if db_affiliations_df is not None and not db_affiliations_df.empty:
        for _, row in db_affiliations_df.iterrows():
            # HCP uses HCP_HCO_AFFILIATION with HCO_* columns, key is HCO_ID
            # HCO uses OUTLET_HCO_AFFILIATION with OUTLET_* columns, key is OUTLET_ID
            if entity_type == "HCP":
                hco_id = row.get('HCO_ID')
                if not hco_id:
                    continue
                addr1 = row.get('HCO_ADDRESS1', '') or ''
                addr2 = row.get('HCO_ADDRESS2', '') or ''
                hco_name = row.get('HCO_NAME', '')
                hco_city = row.get('HCO_CITY', '')
                hco_state = row.get('HCO_STATE', '')
                hco_zip = row.get('HCO_ZIP', '')
                source_label = "HCOS data"
                key = hco_id
            else:
                # OUTLET_HCO_AFFILIATION uses OUTLET_ID as key
                # Use bracket notation for pandas Series access
                outlet_id = row['OUTLET_ID'] if 'OUTLET_ID' in row.index else None
                if not outlet_id or pd.isna(outlet_id):
                    continue
                hco_id = row['HCO_ID'] if 'HCO_ID' in row.index else ''
                addr1 = str(row['OUTLET_ADDRESS1']) if 'OUTLET_ADDRESS1' in row.index and pd.notna(row['OUTLET_ADDRESS1']) else ''
                addr2 = str(row['OUTLET_ADDRESS2']) if 'OUTLET_ADDRESS2' in row.index and pd.notna(row['OUTLET_ADDRESS2']) else ''
                hco_name = str(row['OUTLET_NAME']) if 'OUTLET_NAME' in row.index and pd.notna(row['OUTLET_NAME']) else ''
                hco_city = str(row['OUTLET_CITY']) if 'OUTLET_CITY' in row.index and pd.notna(row['OUTLET_CITY']) else ''
                hco_state = str(row['OUTLET_STATE']) if 'OUTLET_STATE' in row.index and pd.notna(row['OUTLET_STATE']) else ''
                hco_zip = str(row['OUTLET_ZIP']) if 'OUTLET_ZIP' in row.index and pd.notna(row['OUTLET_ZIP']) else ''
                source_label = "DB data"
                key = outlet_id
            
            full_address = f"{addr1}, {addr2}".strip(", ") if addr2 else addr1
            
            all_affiliations[key] = {
                "SOURCE": source_label,
                "HCO ID": hco_id if entity_type == "HCP" else outlet_id,
                "HCO NAME": hco_name,
                "HCO ADDRESS": full_address,
                "HCO CITY": hco_city,
                "HCO STATE": hco_state,
                "HCO ZIP": hco_zip,
            }
    
    # Filter and add AI affiliations
    entity_name_upper = entity_name.upper().strip() if entity_name else ""
    entity_name_parts = [p.strip() for p in entity_name_upper.replace(',', ' ').replace('.', ' ').split() if len(p.strip()) > 2]
    
    for idx, hco in enumerate(ai_affiliations):
        hco_name = hco.get('HCO_Name', hco.get('HCO NAME', ''))
        if not hco_name or pd.isna(hco_name) or str(hco_name).strip() == "":
            continue
            
        hco_name_upper = str(hco_name).upper().strip()
        
        # Skip if HCO name contains the entity's name (likely self-reference)
        is_self_reference = False
        if entity_name_parts:
            matching_parts = sum(1 for part in entity_name_parts if part in hco_name_upper)
            if matching_parts >= len(entity_name_parts) / 2:
                is_self_reference = True
        
        if not is_self_reference:
            hco_id = hco.get('HCO_ID', hco.get('HCO ID', ''))
            # Use unique key for AI-generated entries
            key = hco_id if hco_id and hco_id not in all_affiliations and hco_id != 'N/A' else f"ai_generated_{idx}"
            
            all_affiliations[key] = {
                "SOURCE": "Generated by AI",
                "HCO ID": hco_id if hco_id and hco_id != 'N/A' else "",
                "HCO NAME": hco_name,
                "HCO ADDRESS": hco.get('HCO_Address1', hco.get('HCO ADDRESS', '')),
                "HCO CITY": hco.get('HCO_City', hco.get('HCO CITY', '')),
                "HCO STATE": hco.get('HCO_State', hco.get('HCO STATE', '')),
                "HCO ZIP": hco.get('HCO_ZIP', hco.get('HCO ZIP', '')),
            }
    
    return all_affiliations


def render_affiliation_expander(
    session,
    all_affiliations: Dict[str, Dict[str, Any]],
    current_record: Dict[str, Any],
    entity_type: str = "HCP",
    primary_id_field: str = "PRIMARY_AFFL_HCO_ACCOUNT_ID",
    is_new_record: bool = False
):
    """
    Render the affiliation expander with priority ranking and Set as Primary functionality.
    
    Args:
        session: Snowflake session
        all_affiliations: Dictionary of all affiliations
        current_record: Current entity record
        entity_type: "HCP" or "HCO"
        primary_id_field: Field name for primary affiliation ID
        is_new_record: Whether this is a new record (Web Search flow)
    """
    entity_name = current_record.get('Name', current_record.get('NAME', 'N/A'))
    entity_npi = current_record.get('NPI', 'N/A')
    record_id = current_record.get('ID', 'NEW')
    
    if entity_type == "HCP":
        expander_title = f"HCO Affiliation information of : {entity_name} (NPI: {entity_npi})"
    else:
        expander_title = f"HCO Affiliation information of : {entity_name}"
    
    with st.expander(expander_title, expanded=False):
        if not all_affiliations:
            st.info("No HCO affiliations were found.")
            return
        
        # Headers
        hco_headers = ["Status", "SOURCE", "HCO ID", "HCO NAME", "HCO ADDRESS", "HCO CITY", "HCO STATE", "HCO ZIP", "Priority", "Reason"]
        header_cols = st.columns([1.5, 1.5, 1.2, 2.5, 2, 1.2, 1.2, 1.2, 0.8, 1])
        for col_obj, header_name in zip(header_cols, hco_headers):
            col_obj.markdown(f"**{header_name}**")
        
        # Get current primary ID
        primary_id_val = current_record.get(primary_id_field)
        true_primary_id = None
        try:
            true_primary_id = int(primary_id_val) if pd.notna(primary_id_val) else None
        except (ValueError, TypeError):
            pass
        
        # Priority rankings cache
        cache_key = f"priority_{entity_type}_{record_id}"
        affiliation_keys = sorted([str(k) for k in all_affiliations.keys()])
        full_cache_key = f"{cache_key}_{'_'.join(affiliation_keys[:5])}"
        
        if 'priority_rankings_cache' not in st.session_state:
            st.session_state.priority_rankings_cache = {}
        
        priority_rankings = st.session_state.priority_rankings_cache.get(full_cache_key, {})
        
        # Show button to analyze priorities if not already analyzed
        if not priority_rankings:
            st.markdown("---")
            col1, col2, col3 = st.columns([2, 2, 2])
            with col2:
                if st.button("ðŸŽ¯ Analyze Priority Order with AI", key=f"analyze_priorities_{record_id}", use_container_width=True):
                    st.session_state[f'analyze_priorities_clicked_{full_cache_key}'] = True
                    st.rerun()
            
            # Check if button was clicked to trigger analysis
            if st.session_state.get(f'analyze_priorities_clicked_{full_cache_key}', False):
                affiliations_list = list(all_affiliations.items())
                
                status_placeholder = st.empty()
                status_placeholder.info("ðŸ¤– **AI Analysis in Progress**\n\nSending affiliation data to OpenAI to determine priority order and reasoning...")
                
                with st.spinner("â³ Fetching priority rankings and reasons from OpenAI..."):
                    priority_rankings = get_affiliation_priorities_from_llm(
                        session,
                        current_record,
                        affiliations_list,
                        entity_type
                    )
                
                status_placeholder.empty()
                st.toast("âœ… AI analysis complete! Affiliations ranked by priority.", icon="ðŸŽ¯")
                
                st.session_state.priority_rankings_cache[full_cache_key] = priority_rankings
                st.session_state[f'analyze_priorities_clicked_{full_cache_key}'] = False
                st.rerun()
        
        # Store priority rankings in session state
        st.session_state.priority_reasons = priority_rankings
        
        # Sort affiliations by priority if available
        def get_priority_for_sort(item):
            if not priority_rankings:
                return 0
            try:
                return int(priority_rankings.get(str(item[0]), {}).get("priority", 999))
            except (ValueError, TypeError):
                return 999
        
        sorted_affiliations = sorted(all_affiliations.items(), key=get_priority_for_sort)
        
        # Render each affiliation row
        for hco_id, hco_data in sorted_affiliations:
            row_cols = st.columns([1.5, 1.5, 1.2, 2.5, 2, 1.2, 1.2, 1.2, 0.8, 1])
            
            is_primary = False
            try:
                is_primary = hco_id != "N/A" and true_primary_id is not None and int(hco_id) == true_primary_id
            except (ValueError, TypeError):
                pass
            
            # Status column - Set as Primary button
            with row_cols[0]:
                if is_primary:
                    st.markdown("âœ… **Primary**")
                else:
                    btn_text = "Add & Set Primary" if is_new_record else "Set as Primary"
                    if st.button(btn_text, key=f"set_primary_{hco_id}"):
                        st.session_state.show_primary_confirm_dialog = True
                        st.session_state.primary_hco_id = hco_id
                        st.session_state.primary_hco_data = hco_data
                        st.rerun()
            
            # Source column
            source = hco_data.get("SOURCE", "")
            is_ai_source = (source == "Generated by AI")
            row_cols[1].write(source)
            
            # HCO ID column
            if is_ai_source:
                row_cols[2].write("")
            else:
                row_cols[2].write(str(hco_data.get("HCO ID", "")))
            
            # Other columns
            row_cols[3].write(hco_data.get("HCO NAME", ""))
            row_cols[4].write(hco_data.get("HCO ADDRESS", ""))
            row_cols[5].write(hco_data.get("HCO CITY", ""))
            row_cols[6].write(hco_data.get("HCO STATE", ""))
            row_cols[7].write(hco_data.get("HCO ZIP", ""))
            
            # Priority column
            priority_info = priority_rankings.get(str(hco_id), {"priority": "-", "reason": "N/A"})
            row_cols[8].write(str(priority_info.get("priority", "-")))
            
            # Reason button column
            with row_cols[9]:
                if priority_rankings:
                    reason_key = f"reason_{hco_id}"
                    if st.button("â„¹ï¸", key=reason_key, help="Click to see why this priority was assigned"):
                        st.session_state.show_reason_popup = True
                        st.session_state.reason_popup_data = {
                            "hco_name": hco_data.get("HCO NAME", "Unknown"),
                            "priority": priority_info.get("priority", "-"),
                            "reason": priority_info.get("reason", "No reason available")
                        }
                        st.rerun()
                else:
                    st.write("-")


def render_primary_confirm_dialog(
    session,
    dialog_placeholder,
    selected_record: Dict[str, Any],
    entity_type: str = "HCP",
    is_new_record: bool = False
):
    """
    Render the confirmation dialog for setting primary affiliation.
    
    Args:
        session: Snowflake session
        dialog_placeholder: Streamlit placeholder for the dialog
        selected_record: Current entity record
        entity_type: "HCP" or "HCO"
        is_new_record: Whether this is a new record
    """
    if not st.session_state.get('show_primary_confirm_dialog'):
        return False
    
    with dialog_placeholder.container():
        if is_new_record:
            st.warning(
                f"This is a new {entity_type} record. Setting primary affiliation will:\n"
                "1. Create a new affiliation record\n"
                "2. Set this as the primary affiliation",
                icon="âš ï¸"
            )
        else:
            st.warning("Are you sure you want to change the primary affiliation? This will update the main record.", icon="âš ï¸")
        
        new_primary_id = st.session_state.primary_hco_id
        new_hco_data = st.session_state.get('primary_hco_data', {})
        new_primary_name = new_hco_data.get('HCO NAME', new_hco_data.get('HCO_Name', 'N/A'))
        
        # Check if AI-generated
        is_ai_generated = (
            str(new_primary_id).startswith('ai_generated_') or 
            new_hco_data.get('SOURCE') == 'Generated by AI'
        )
        
        if is_ai_generated:
            proposed_display = f"NEW ID (will be generated) - {new_primary_name}"
        else:
            proposed_display = f"ID: {new_primary_id} ({new_primary_name})"
        
        # Display change summary
        change_df = pd.DataFrame({
            "Field": ["Record ID", "Record Name", "Proposed Primary HCO"],
            "Value": [
                selected_record.get('ID', 'NEW'),
                selected_record.get('NAME', 'N/A'),
                proposed_display
            ]
        })
        st.dataframe(change_df.set_index('Field'), use_container_width=True)
        
        col1, col2 = st.columns([1, 1])
        
        confirm_btn_text = "Yes, Create & Set Primary" if (is_new_record or is_ai_generated) else "Yes, Set Primary"
        
        with col1:
            if st.button(confirm_btn_text, key="confirm_primary_yes"):
                spinner_text = "Creating affiliation and setting primary..." if (is_new_record or is_ai_generated) else "Updating primary affiliation..."
                with st.spinner(spinner_text):
                    success, final_hco_id, message = set_primary_affiliation(
                        session=session,
                        entity_type=entity_type,
                        selected_record=selected_record,
                        hco_data=new_hco_data,
                        hco_id=new_primary_id,
                        is_new_record=is_new_record
                    )
                
                if success:
                    st.session_state.show_popup = True
                    st.session_state.popup_message_info = {
                        'type': 'primary_success',
                        'hco_id': final_hco_id
                    }
                    st.session_state.show_primary_confirm_dialog = False
                    st.session_state.primary_hco_data = None
                    # Stay on enrichment page - just rerun to show success popup
                    st.rerun()
                else:
                    st.error(message)
                    st.session_state.show_primary_confirm_dialog = False
                    st.rerun()
        
        with col2:
            if st.button("Cancel", key="confirm_primary_cancel"):
                st.session_state.show_primary_confirm_dialog = False
                st.session_state.primary_hco_data = None
                st.rerun()
    
    return True


def transform_perplexity_affiliations(perplexity_response: Dict[str, Any], entity_type: str) -> List[Dict[str, Any]]:
    """
    Transform Perplexity API response to a list of affiliation dictionaries.
    
    Args:
        perplexity_response: Response from Perplexity API
        entity_type: "HCP" or "HCO"
        
    Returns:
        List of affiliation dictionaries
    """
    data_key = "hcp_affiliation_data" if entity_type == "HCP" else "hco_affiliation_data"
    affiliation_data = perplexity_response.get(data_key, {})
    
    if not affiliation_data:
        return []
    
    # Get the length of lists
    hco_names = affiliation_data.get('HCO_Name', [])
    if not hco_names:
        return []
    
    affiliations = []
    for i in range(len(hco_names)):
        aff = {
            'HCO_ID': affiliation_data.get('HCO_ID', [''])[i] if i < len(affiliation_data.get('HCO_ID', [])) else '',
            'HCO_Name': hco_names[i],
            'HCO_Address1': affiliation_data.get('HCO_Address1', [''])[i] if i < len(affiliation_data.get('HCO_Address1', [])) else '',
            'HCO_City': affiliation_data.get('HCO_City', [''])[i] if i < len(affiliation_data.get('HCO_City', [])) else '',
            'HCO_State': affiliation_data.get('HCO_State', [''])[i] if i < len(affiliation_data.get('HCO_State', [])) else '',
            'HCO_ZIP': affiliation_data.get('HCO_ZIP', [''])[i] if i < len(affiliation_data.get('HCO_ZIP', [])) else '',
        }
        if entity_type == "HCP":
            aff['NPI'] = affiliation_data.get('NPI', [''])[i] if i < len(affiliation_data.get('NPI', [])) else ''
        affiliations.append(aff)
    
    return affiliations
